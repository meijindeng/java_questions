# 反射
反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。

## 反射提供的功能
- 在运行时，判断任意一个对象所属的类；
- 在运行时，构造任意一个类的对象；
- 在运行时，判断任意一个类所具有的成员变量和方法；
- 在运行时，调用任意一个对象的方法；
- 生成动态代理。

## 具体实现
### Test1
- 通过反射获取类。三种方式：Class.forName();  类名.class;  对象.getClass()。

- 通过反射获取所有的方法。

  1、通过getMethods()获取所有的公共方法（1.本类、父类、接口中的所有方法；2.符合访问修饰符规律public）。

  2、通过getDeclaredMethods()获取当前类的所有方法（1.只能是当前类；2.忽略访问修饰符限制）。

- 通过反射获取所有的接口。通过getInterfaces()获取接口。

- 通过反射获取所有的父类。通过getSuperclass()获取父类。

- 通过反射获取所有的构造方法。通过getConstructors()获取构造方法。

- 通过反射获取所有的属性。

  1、通过getFields()获取所有的公共属性（1.本类、父类、接口中的所有属性；2.符合访问修饰符规律public）。

  2、通过getDeclaredFields()获取当前类的所有属性（1.只能是当前类；2.忽略访问修饰符限制）。

- 通过反射获取当前所代表类（接口）的对象（实例）。通过newInstance()获取。

### Test2

- 通过反射获取Person类；

- 通过newInstance()得到对象的实例；

- 通过反射操作属性和方法；

  1、getDeclaredField()获取某一个属性，传入哪个属性设置哪个属性（getDeclaredField没有s）；

  2、有些属性是private私有的，只能通过set进行赋值，此时需要修改属性的访问权限，设置setAccessible为true，暂时把权限打开；

  3、getDeclaredMethod()获取某一个方法，传入方法名和参数（getDeclaredMethod没有s）；

  4、有些方法是private私有的，也是需要打开修改私有方法的访问权限；

  5、属性通过set赋值，方法通过invoke。

### Test3

- 动态加载类名和方法；

  1、创建一个文本文件，里面写入调用的类名classname和方法名methodname；
  
  2、使用FileReader流读取文件，使用getProperty获取类名和方法；
  
  3、通过反射调用类名和方法名。

- 反射可以越过泛型检查（不建议使用，了解即可）；

  1、创建Integer类型的集合，并add数据；

  2、反射的一个入口方法，通过getMethod，反射调add方法，类型改为Object（任何类型）；

  3、invoke传入list对象和参数值。
  
- 通过一个方法给任意对象的属性赋值；

  1、在一个实体类中创建一个方法setProperty，该方法可以给任何对象、属性赋值；

  2、创建一个工具类PropertyUtil，该类需要传入对象obj、属性propertyName、值value；

  3、在工具类中获取反射入口、属性，打开访问权限，给属性赋值；

  4、new一个对象，调用工具类中的方法，给对象的任意属性赋值。

